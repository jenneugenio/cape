package controller

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/felixge/httpsnoop"
	"github.com/gofrs/uuid"
	"github.com/rs/zerolog"

	errors "github.com/dropoutlabs/cape/partyerrors"
)

// ContextKey is a type alias used for storing data in a context
type ContextKey string

const (
	// RequestIDContextKey is the name of the key stored on the contet
	RequestIDContextKey ContextKey = "request-id"

	// LoggerContextKey is the name of the logger key stored on the context
	LoggerContextKey ContextKey = "logger"
)

// RequestID returns the request id stored on a given context
func RequestID(ctx context.Context) uuid.UUID {
	id := ctx.Value(RequestIDContextKey)
	if id == nil {
		panic("request id not available on context")
	}

	return id.(uuid.UUID)
}

// Logger returns the logger stored on a given context
func Logger(ctx context.Context) zerolog.Logger {
	logger := ctx.Value(LoggerContextKey)
	if logger == nil {
		panic("logger not available on context")
	}

	return logger.(zerolog.Logger)
}

// requestIDMiddleware sets a UUID on the response header and request context
// for use in tracing and
func requestIDMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
		id, err := uuid.NewV4()
		if err != nil {
			panic(fmt.Sprintf("Could not generate a v4 uuid: %s", err))
		}

		ctx := context.WithValue(req.Context(), RequestIDContextKey, id)
		req = req.WithContext(ctx)
		rw.Header().Set("X-Request-ID", id.String())
		next.ServeHTTP(rw, req)
	})
}

// logMiddleware sets a zerolog.Logger on the request context for use in
// downstream callers. This middleware relies on the requestIDMiddleware.
func logMiddleware(log *zerolog.Logger, next http.Handler) http.Handler {
	return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
		ctx := req.Context()
		requestID := RequestID(ctx)
		logger := log.With().Str("request_id", requestID.String()).Logger()

		ctx = context.WithValue(ctx, LoggerContextKey, logger)
		req = req.WithContext(ctx)
		next.ServeHTTP(rw, req)
	})
}

// roundtripLoggerMiddleware logs information about request and response
// generated by the server. It depends on the logMiddleware.
func roundtripLoggerMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
		metrics := httpsnoop.CaptureMetrics(next, rw, req)
		logger := Logger(req.Context())

		logger.Info().
			Int("status", metrics.Code).
			Str("method", req.Method).
			Str("uri", req.RequestURI).
			Int64("duration", int64(metrics.Duration.Seconds()/1000)).
			Int64("size", metrics.Written).
			Str("referer", req.Referer()).
			Str("user-agent", req.UserAgent()).
			Msg("Finished")
	})
}

// recoveryMiddleware catches any panics that occur in the call chain of the
// http request and response. If a panic does occur the panic is captured, a
// log is produced, and an internal server error is returned to the caller.
func recoveryMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
		logger := Logger(req.Context())
		defer func() {
			if p := recover(); p != nil {
				// If the panic contains an error then we want to log that
				// error otherwise we want to log the fact that we encountered
				// an error.
				//
				// XXX: It'd be helpful here to capture some portion of the
				// stack trace and log that as well.
				e, ok := p.(error)
				if !ok {
					e = errors.New(errors.UnknownCause, "Encountered panic: %s", p)
				}
				logger.Err(e).Msg("Encountered a panic; responding with a 500 error")

				// The following is the error we want to propagate externally
				err := errors.New(errors.UnknownCause, "Internal Server Error")
				respondWithError(rw, err)
			}
		}()

		next.ServeHTTP(rw, req)
	})
}

// respondWithError is a middleware helper for responding to an http request
// with a specific error. The error is written out in JSON and must be a
// partyerrors.Error.
func respondWithError(rw http.ResponseWriter, err error) {
	e := errors.ToError(err)
	respondWithJSON(rw, e.StatusCode(), e)
}

// respondWithJSON is a middleware helper for responding to an http request
// with a specific json response. If an error is encountered a log is produced.
func respondWithJSON(rw http.ResponseWriter, code int, out interface{}) {
	rw.Header().Set("Content-Type", "application/json")
	rw.WriteHeader(code)

	enc := json.NewEncoder(rw)
	if err := enc.Encode(out); err != nil {
		panic(fmt.Sprintf("Could not marshal json to response: %s", err))
	}
}
