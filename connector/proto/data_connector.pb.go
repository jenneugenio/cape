// Code generated by protoc-gen-go. DO NOT EDIT.
// source: data_connector.proto

package proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type RecordType int32

const (
	RecordType_DOCUMENT RecordType = 0
)

var RecordType_name = map[int32]string{
	0: "DOCUMENT",
}

var RecordType_value = map[string]int32{
	"DOCUMENT": 0,
}

func (x RecordType) String() string {
	return proto.EnumName(RecordType_name, int32(x))
}

func (RecordType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8084a2705774cfd7, []int{0}
}

// We need to know the exact field type so the client can convert the data into the appropriate field type.
type FieldType int32

const (
	FieldType_BIGINT       FieldType = 0
	FieldType_BIT          FieldType = 2
	FieldType_VARBIT       FieldType = 3
	FieldType_BOOL         FieldType = 4
	FieldType_BOX          FieldType = 5
	FieldType_BYTEA        FieldType = 6
	FieldType_CHAR         FieldType = 7
	FieldType_VARCHAR      FieldType = 8
	FieldType_CIDR         FieldType = 9
	FieldType_CIRCLE       FieldType = 10
	FieldType_DATE         FieldType = 11
	FieldType_DOUBLE       FieldType = 12
	FieldType_INET         FieldType = 13
	FieldType_INT          FieldType = 14
	FieldType_INTERVAL     FieldType = 15
	FieldType_JSON         FieldType = 16
	FieldType_JSONB        FieldType = 17
	FieldType_LINE         FieldType = 18
	FieldType_LSEG         FieldType = 19
	FieldType_MACADDR      FieldType = 20
	FieldType_MACADDR8     FieldType = 21
	FieldType_MONEY        FieldType = 22
	FieldType_NUMERIC      FieldType = 23
	FieldType_PATH         FieldType = 24
	FieldType_PGLSN        FieldType = 25
	FieldType_POINT        FieldType = 26
	FieldType_POLYGON      FieldType = 27
	FieldType_REAL         FieldType = 28
	FieldType_SMALLINT     FieldType = 29
	FieldType_TEXT         FieldType = 32
	FieldType_TIME         FieldType = 33
	FieldType_TIMETZ       FieldType = 34
	FieldType_TIMESTAMP    FieldType = 35
	FieldType_TIMESTAMPTZ  FieldType = 36
	FieldType_TSQUERY      FieldType = 37
	FieldType_TSVECTOR     FieldType = 38
	FieldType_TXIDSNAPSHOT FieldType = 39
	FieldType_UUID         FieldType = 40
	FieldType_XML          FieldType = 41
)

var FieldType_name = map[int32]string{
	0:  "BIGINT",
	2:  "BIT",
	3:  "VARBIT",
	4:  "BOOL",
	5:  "BOX",
	6:  "BYTEA",
	7:  "CHAR",
	8:  "VARCHAR",
	9:  "CIDR",
	10: "CIRCLE",
	11: "DATE",
	12: "DOUBLE",
	13: "INET",
	14: "INT",
	15: "INTERVAL",
	16: "JSON",
	17: "JSONB",
	18: "LINE",
	19: "LSEG",
	20: "MACADDR",
	21: "MACADDR8",
	22: "MONEY",
	23: "NUMERIC",
	24: "PATH",
	25: "PGLSN",
	26: "POINT",
	27: "POLYGON",
	28: "REAL",
	29: "SMALLINT",
	32: "TEXT",
	33: "TIME",
	34: "TIMETZ",
	35: "TIMESTAMP",
	36: "TIMESTAMPTZ",
	37: "TSQUERY",
	38: "TSVECTOR",
	39: "TXIDSNAPSHOT",
	40: "UUID",
	41: "XML",
}

var FieldType_value = map[string]int32{
	"BIGINT":       0,
	"BIT":          2,
	"VARBIT":       3,
	"BOOL":         4,
	"BOX":          5,
	"BYTEA":        6,
	"CHAR":         7,
	"VARCHAR":      8,
	"CIDR":         9,
	"CIRCLE":       10,
	"DATE":         11,
	"DOUBLE":       12,
	"INET":         13,
	"INT":          14,
	"INTERVAL":     15,
	"JSON":         16,
	"JSONB":        17,
	"LINE":         18,
	"LSEG":         19,
	"MACADDR":      20,
	"MACADDR8":     21,
	"MONEY":        22,
	"NUMERIC":      23,
	"PATH":         24,
	"PGLSN":        25,
	"POINT":        26,
	"POLYGON":      27,
	"REAL":         28,
	"SMALLINT":     29,
	"TEXT":         32,
	"TIME":         33,
	"TIMETZ":       34,
	"TIMESTAMP":    35,
	"TIMESTAMPTZ":  36,
	"TSQUERY":      37,
	"TSVECTOR":     38,
	"TXIDSNAPSHOT": 39,
	"UUID":         40,
	"XML":          41,
}

func (x FieldType) String() string {
	return proto.EnumName(FieldType_name, int32(x))
}

func (FieldType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8084a2705774cfd7, []int{1}
}

type QueryRequest struct {
	DataSource           string   `protobuf:"bytes,1,opt,name=data_source,json=dataSource,proto3" json:"data_source,omitempty"`
	Query                string   `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
	Limit                int64    `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset               int64    `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryRequest) Reset()         { *m = QueryRequest{} }
func (m *QueryRequest) String() string { return proto.CompactTextString(m) }
func (*QueryRequest) ProtoMessage()    {}
func (*QueryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8084a2705774cfd7, []int{0}
}

func (m *QueryRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryRequest.Unmarshal(m, b)
}
func (m *QueryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryRequest.Marshal(b, m, deterministic)
}
func (m *QueryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRequest.Merge(m, src)
}
func (m *QueryRequest) XXX_Size() int {
	return xxx_messageInfo_QueryRequest.Size(m)
}
func (m *QueryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRequest proto.InternalMessageInfo

func (m *QueryRequest) GetDataSource() string {
	if m != nil {
		return m.DataSource
	}
	return ""
}

func (m *QueryRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *QueryRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *QueryRequest) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type Record struct {
	// Schema is only available on the first message
	Schema *Schema `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	// Each field value goes over the wire and the number of values maps to the number of fields in the Schema.
	Fields               []*Field `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Record) Reset()         { *m = Record{} }
func (m *Record) String() string { return proto.CompactTextString(m) }
func (*Record) ProtoMessage()    {}
func (*Record) Descriptor() ([]byte, []int) {
	return fileDescriptor_8084a2705774cfd7, []int{1}
}

func (m *Record) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Record.Unmarshal(m, b)
}
func (m *Record) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Record.Marshal(b, m, deterministic)
}
func (m *Record) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Record.Merge(m, src)
}
func (m *Record) XXX_Size() int {
	return xxx_messageInfo_Record.Size(m)
}
func (m *Record) XXX_DiscardUnknown() {
	xxx_messageInfo_Record.DiscardUnknown(m)
}

var xxx_messageInfo_Record proto.InternalMessageInfo

func (m *Record) GetSchema() *Schema {
	if m != nil {
		return m.Schema
	}
	return nil
}

func (m *Record) GetFields() []*Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

type Field struct {
	// Types that are valid to be assigned to Value:
	//	*Field_Int32
	//	*Field_Int64
	//	*Field_Timestamp
	//	*Field_Float
	//	*Field_Double
	//	*Field_String_
	//	*Field_Bytes
	//	*Field_Bool
	Value                isField_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Field) Reset()         { *m = Field{} }
func (m *Field) String() string { return proto.CompactTextString(m) }
func (*Field) ProtoMessage()    {}
func (*Field) Descriptor() ([]byte, []int) {
	return fileDescriptor_8084a2705774cfd7, []int{2}
}

func (m *Field) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Field.Unmarshal(m, b)
}
func (m *Field) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Field.Marshal(b, m, deterministic)
}
func (m *Field) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Field.Merge(m, src)
}
func (m *Field) XXX_Size() int {
	return xxx_messageInfo_Field.Size(m)
}
func (m *Field) XXX_DiscardUnknown() {
	xxx_messageInfo_Field.DiscardUnknown(m)
}

var xxx_messageInfo_Field proto.InternalMessageInfo

type isField_Value interface {
	isField_Value()
}

type Field_Int32 struct {
	Int32 int32 `protobuf:"varint,1,opt,name=int32,proto3,oneof"`
}

type Field_Int64 struct {
	Int64 int64 `protobuf:"varint,2,opt,name=int64,proto3,oneof"`
}

type Field_Timestamp struct {
	Timestamp *timestamp.Timestamp `protobuf:"bytes,3,opt,name=timestamp,proto3,oneof"`
}

type Field_Float struct {
	Float float32 `protobuf:"fixed32,4,opt,name=float,proto3,oneof"`
}

type Field_Double struct {
	Double float64 `protobuf:"fixed64,5,opt,name=double,proto3,oneof"`
}

type Field_String_ struct {
	String_ string `protobuf:"bytes,6,opt,name=string,proto3,oneof"`
}

type Field_Bytes struct {
	Bytes []byte `protobuf:"bytes,7,opt,name=bytes,proto3,oneof"`
}

type Field_Bool struct {
	Bool bool `protobuf:"varint,8,opt,name=bool,proto3,oneof"`
}

func (*Field_Int32) isField_Value() {}

func (*Field_Int64) isField_Value() {}

func (*Field_Timestamp) isField_Value() {}

func (*Field_Float) isField_Value() {}

func (*Field_Double) isField_Value() {}

func (*Field_String_) isField_Value() {}

func (*Field_Bytes) isField_Value() {}

func (*Field_Bool) isField_Value() {}

func (m *Field) GetValue() isField_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Field) GetInt32() int32 {
	if x, ok := m.GetValue().(*Field_Int32); ok {
		return x.Int32
	}
	return 0
}

func (m *Field) GetInt64() int64 {
	if x, ok := m.GetValue().(*Field_Int64); ok {
		return x.Int64
	}
	return 0
}

func (m *Field) GetTimestamp() *timestamp.Timestamp {
	if x, ok := m.GetValue().(*Field_Timestamp); ok {
		return x.Timestamp
	}
	return nil
}

func (m *Field) GetFloat() float32 {
	if x, ok := m.GetValue().(*Field_Float); ok {
		return x.Float
	}
	return 0
}

func (m *Field) GetDouble() float64 {
	if x, ok := m.GetValue().(*Field_Double); ok {
		return x.Double
	}
	return 0
}

func (m *Field) GetString_() string {
	if x, ok := m.GetValue().(*Field_String_); ok {
		return x.String_
	}
	return ""
}

func (m *Field) GetBytes() []byte {
	if x, ok := m.GetValue().(*Field_Bytes); ok {
		return x.Bytes
	}
	return nil
}

func (m *Field) GetBool() bool {
	if x, ok := m.GetValue().(*Field_Bool); ok {
		return x.Bool
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Field) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Field_Int32)(nil),
		(*Field_Int64)(nil),
		(*Field_Timestamp)(nil),
		(*Field_Float)(nil),
		(*Field_Double)(nil),
		(*Field_String_)(nil),
		(*Field_Bytes)(nil),
		(*Field_Bool)(nil),
	}
}

// Schema contains information
type Schema struct {
	DataSource           string       `protobuf:"bytes,1,opt,name=data_source,json=dataSource,proto3" json:"data_source,omitempty"`
	Target               string       `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	Type                 RecordType   `protobuf:"varint,3,opt,name=type,proto3,enum=cape.RecordType" json:"type,omitempty"`
	Fields               []*FieldInfo `protobuf:"bytes,4,rep,name=fields,proto3" json:"fields,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Schema) Reset()         { *m = Schema{} }
func (m *Schema) String() string { return proto.CompactTextString(m) }
func (*Schema) ProtoMessage()    {}
func (*Schema) Descriptor() ([]byte, []int) {
	return fileDescriptor_8084a2705774cfd7, []int{3}
}

func (m *Schema) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Schema.Unmarshal(m, b)
}
func (m *Schema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Schema.Marshal(b, m, deterministic)
}
func (m *Schema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Schema.Merge(m, src)
}
func (m *Schema) XXX_Size() int {
	return xxx_messageInfo_Schema.Size(m)
}
func (m *Schema) XXX_DiscardUnknown() {
	xxx_messageInfo_Schema.DiscardUnknown(m)
}

var xxx_messageInfo_Schema proto.InternalMessageInfo

func (m *Schema) GetDataSource() string {
	if m != nil {
		return m.DataSource
	}
	return ""
}

func (m *Schema) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *Schema) GetType() RecordType {
	if m != nil {
		return m.Type
	}
	return RecordType_DOCUMENT
}

func (m *Schema) GetFields() []*FieldInfo {
	if m != nil {
		return m.Fields
	}
	return nil
}

// FieldInfo represents all information about a field including its type, the number of bits or bytes, and the fields name.
type FieldInfo struct {
	Field                FieldType `protobuf:"varint,1,opt,name=field,proto3,enum=cape.FieldType" json:"field,omitempty"`
	Size                 int64     `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	Name                 string    `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *FieldInfo) Reset()         { *m = FieldInfo{} }
func (m *FieldInfo) String() string { return proto.CompactTextString(m) }
func (*FieldInfo) ProtoMessage()    {}
func (*FieldInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8084a2705774cfd7, []int{4}
}

func (m *FieldInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FieldInfo.Unmarshal(m, b)
}
func (m *FieldInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FieldInfo.Marshal(b, m, deterministic)
}
func (m *FieldInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldInfo.Merge(m, src)
}
func (m *FieldInfo) XXX_Size() int {
	return xxx_messageInfo_FieldInfo.Size(m)
}
func (m *FieldInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FieldInfo proto.InternalMessageInfo

func (m *FieldInfo) GetField() FieldType {
	if m != nil {
		return m.Field
	}
	return FieldType_BIGINT
}

func (m *FieldInfo) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *FieldInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func init() {
	proto.RegisterEnum("cape.RecordType", RecordType_name, RecordType_value)
	proto.RegisterEnum("cape.FieldType", FieldType_name, FieldType_value)
	proto.RegisterType((*QueryRequest)(nil), "cape.QueryRequest")
	proto.RegisterType((*Record)(nil), "cape.Record")
	proto.RegisterType((*Field)(nil), "cape.Field")
	proto.RegisterType((*Schema)(nil), "cape.Schema")
	proto.RegisterType((*FieldInfo)(nil), "cape.FieldInfo")
}

func init() {
	proto.RegisterFile("data_connector.proto", fileDescriptor_8084a2705774cfd7)
}

var fileDescriptor_8084a2705774cfd7 = []byte{
	// 807 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0x51, 0x6f, 0xe2, 0x46,
	0x10, 0xc6, 0x01, 0x1b, 0x18, 0x48, 0x32, 0xdd, 0xa6, 0xa9, 0x4b, 0x5b, 0x1d, 0xe5, 0x72, 0x3d,
	0x7a, 0x95, 0xb8, 0x8a, 0x3b, 0x9d, 0xaa, 0xb6, 0x2f, 0x06, 0xbb, 0xc1, 0x95, 0xb1, 0xb9, 0xf5,
	0x12, 0x25, 0x79, 0xa9, 0x1c, 0xb2, 0xa4, 0x48, 0x80, 0x39, 0x6c, 0x2a, 0xa5, 0xbf, 0xa2, 0xff,
	0xac, 0xff, 0xa6, 0xcf, 0xd5, 0xec, 0x3a, 0x24, 0x7d, 0xba, 0x27, 0xe6, 0xfb, 0xbe, 0xd9, 0x6f,
	0x66, 0x67, 0xcc, 0xc2, 0xc9, 0x6d, 0x92, 0x27, 0xbf, 0xcf, 0xd2, 0xf5, 0x5a, 0xce, 0xf2, 0x74,
	0xdb, 0xdb, 0x6c, 0xd3, 0x3c, 0x65, 0x95, 0x59, 0xb2, 0x91, 0xad, 0x67, 0x77, 0x69, 0x7a, 0xb7,
	0x94, 0xaf, 0x15, 0x77, 0xb3, 0x9b, 0xbf, 0xce, 0x17, 0x2b, 0x99, 0xe5, 0xc9, 0x6a, 0xa3, 0xd3,
	0x3a, 0x19, 0x34, 0xdf, 0xef, 0xe4, 0xf6, 0x9e, 0xcb, 0x0f, 0x3b, 0x99, 0xe5, 0xec, 0x19, 0x34,
	0x94, 0x5d, 0x96, 0xee, 0xb6, 0x33, 0x69, 0x1b, 0x6d, 0xa3, 0x5b, 0xe7, 0x40, 0x54, 0xac, 0x18,
	0x76, 0x02, 0xe6, 0x07, 0x3a, 0x60, 0x1f, 0x28, 0x49, 0x03, 0x62, 0x97, 0x8b, 0xd5, 0x22, 0xb7,
	0xcb, 0x6d, 0xa3, 0x5b, 0xe6, 0x1a, 0xb0, 0x53, 0xb0, 0xd2, 0xf9, 0x3c, 0x93, 0xb9, 0x5d, 0x51,
	0x74, 0x81, 0x3a, 0x31, 0x58, 0x5c, 0xce, 0xd2, 0xed, 0x2d, 0x3b, 0x03, 0x2b, 0x9b, 0xfd, 0x21,
	0x57, 0x89, 0xaa, 0xd4, 0xe8, 0x37, 0x7b, 0xd4, 0x76, 0x2f, 0x56, 0x1c, 0x2f, 0x34, 0xf6, 0x1c,
	0xac, 0xf9, 0x42, 0x2e, 0x6f, 0x33, 0xfb, 0xa0, 0x5d, 0xee, 0x36, 0xfa, 0x0d, 0x9d, 0xf5, 0x2b,
	0x71, 0xbc, 0x90, 0x3a, 0xff, 0x1a, 0x60, 0x2a, 0x86, 0x9d, 0x82, 0xb9, 0x58, 0xe7, 0x6f, 0xfa,
	0xca, 0xd3, 0x1c, 0x95, 0xb8, 0x86, 0x05, 0xff, 0xee, 0xad, 0x6a, 0xbd, 0x5c, 0xf0, 0xef, 0xde,
	0xb2, 0x9f, 0xa0, 0xbe, 0x1f, 0x8b, 0xba, 0x40, 0xa3, 0xdf, 0xea, 0xe9, 0xc1, 0xf5, 0x1e, 0x06,
	0xd7, 0x13, 0x0f, 0x19, 0xa3, 0x12, 0x7f, 0x4c, 0x27, 0xcf, 0xf9, 0x32, 0x4d, 0xf4, 0x0d, 0x0f,
	0xc8, 0x53, 0x41, 0x66, 0x83, 0x75, 0x9b, 0xee, 0x6e, 0x96, 0xd2, 0x36, 0xdb, 0x46, 0xd7, 0x18,
	0x95, 0x78, 0x81, 0x49, 0xc9, 0xf2, 0xed, 0x62, 0x7d, 0x67, 0x5b, 0x34, 0x41, 0x52, 0x34, 0x26,
	0xaf, 0x9b, 0xfb, 0x5c, 0x66, 0x76, 0xb5, 0x6d, 0x74, 0x9b, 0xe4, 0xa5, 0x20, 0x3b, 0x81, 0xca,
	0x4d, 0x9a, 0x2e, 0xed, 0x5a, 0xdb, 0xe8, 0xd6, 0x46, 0x25, 0xae, 0xd0, 0xa0, 0x0a, 0xe6, 0x9f,
	0xc9, 0x72, 0x27, 0x3b, 0x7f, 0x1b, 0x60, 0xe9, 0x81, 0x7d, 0x7c, 0x7b, 0xa7, 0x60, 0xe5, 0xc9,
	0xf6, 0x4e, 0xe6, 0xc5, 0xfa, 0x0a, 0xc4, 0xce, 0xa0, 0x92, 0xdf, 0x6f, 0xa4, 0xba, 0xfd, 0x51,
	0x1f, 0xf5, 0x7c, 0xf5, 0x8e, 0xc4, 0xfd, 0x46, 0x72, 0xa5, 0xb2, 0x97, 0xfb, 0x3d, 0x54, 0xd4,
	0x1e, 0x8e, 0x9f, 0xec, 0xc1, 0x5f, 0xcf, 0xd3, 0xfd, 0x2e, 0xae, 0xa1, 0xbe, 0x27, 0xd9, 0x0b,
	0x30, 0x15, 0xad, 0xda, 0x39, 0xfa, 0xdf, 0x21, 0xe5, 0xad, 0x55, 0xc6, 0xa0, 0x92, 0x2d, 0xfe,
	0x92, 0x7a, 0x39, 0x5c, 0xc5, 0xc4, 0xad, 0x93, 0x95, 0x6e, 0xab, 0xce, 0x55, 0xfc, 0xaa, 0x05,
	0xf0, 0xd8, 0x18, 0x6b, 0x42, 0xcd, 0x8d, 0x86, 0xd3, 0xb1, 0x17, 0x0a, 0x2c, 0xbd, 0xfa, 0xa7,
	0x5c, 0x14, 0x56, 0x1a, 0x80, 0x35, 0xf0, 0xcf, 0x7d, 0x52, 0x58, 0x15, 0xca, 0x03, 0x5f, 0xe0,
	0x01, 0x91, 0x17, 0x0e, 0xa7, 0xb8, 0xcc, 0x6a, 0x50, 0x19, 0x44, 0x51, 0x80, 0x15, 0x25, 0x47,
	0x97, 0x68, 0xb2, 0x3a, 0x98, 0x83, 0x2b, 0xe1, 0x39, 0x68, 0x91, 0x3a, 0x1c, 0x39, 0x1c, 0xab,
	0xac, 0x01, 0xd5, 0x0b, 0x87, 0x2b, 0x50, 0x53, 0xb4, 0xef, 0x72, 0xac, 0x93, 0xd5, 0xd0, 0xe7,
	0xc3, 0xc0, 0x43, 0x20, 0xd6, 0x75, 0x84, 0x87, 0x0d, 0x62, 0xdd, 0x68, 0x3a, 0x08, 0x3c, 0x6c,
	0x12, 0xeb, 0x87, 0x9e, 0xc0, 0x43, 0x2a, 0x40, 0x8d, 0x1c, 0x51, 0xc3, 0x7e, 0x28, 0x3c, 0x7e,
	0xe1, 0x04, 0x78, 0x4c, 0x09, 0xbf, 0xc5, 0x51, 0x88, 0x48, 0x85, 0x29, 0x1a, 0xe0, 0x27, 0x44,
	0x06, 0x7e, 0xe8, 0x21, 0x53, 0x51, 0xec, 0x9d, 0xe3, 0xa7, 0xd4, 0xc2, 0xd8, 0x19, 0x3a, 0xae,
	0xcb, 0xf1, 0x84, 0x3c, 0x0a, 0xf0, 0x23, 0x7e, 0x46, 0x27, 0xc7, 0x51, 0xe8, 0x5d, 0xe1, 0x29,
	0x65, 0x85, 0xd3, 0xb1, 0xc7, 0xfd, 0x21, 0x7e, 0x4e, 0x87, 0x27, 0x8e, 0x18, 0xa1, 0x4d, 0x19,
	0x93, 0xf3, 0x20, 0x0e, 0xf1, 0x0b, 0x15, 0x46, 0xd4, 0x49, 0x8b, 0x92, 0x27, 0x51, 0x70, 0x75,
	0x1e, 0x85, 0xf8, 0x25, 0x25, 0x73, 0xcf, 0x09, 0xf0, 0x2b, 0x32, 0x8f, 0xc7, 0x4e, 0x10, 0x50,
	0xd2, 0xd7, 0xc4, 0x0b, 0xef, 0x52, 0x60, 0x5b, 0x45, 0xfe, 0xd8, 0xc3, 0x6f, 0xe8, 0x86, 0x14,
	0x89, 0x6b, 0xec, 0xb0, 0x43, 0xa8, 0x53, 0x1c, 0x0b, 0x67, 0x3c, 0xc1, 0xe7, 0xec, 0x18, 0x1a,
	0x7b, 0x28, 0xae, 0xf1, 0x8c, 0x8a, 0x88, 0xf8, 0xfd, 0xd4, 0xe3, 0x57, 0xf8, 0x82, 0xac, 0x45,
	0x7c, 0xe1, 0x0d, 0x45, 0xc4, 0xf1, 0x5b, 0x86, 0xd0, 0x14, 0x97, 0xbe, 0x1b, 0x87, 0xce, 0x24,
	0x1e, 0x45, 0x02, 0x5f, 0x52, 0x89, 0xe9, 0xd4, 0x77, 0xb1, 0x4b, 0xe3, 0xba, 0x1c, 0x07, 0xf8,
	0x5d, 0xff, 0x17, 0x38, 0x74, 0x93, 0x3c, 0x19, 0x3e, 0xbc, 0x6e, 0xec, 0x7b, 0x30, 0xd5, 0x83,
	0xc5, 0x98, 0xfe, 0x8e, 0x9e, 0xbe, 0x5e, 0xad, 0xe6, 0xd3, 0x0f, 0xf7, 0x07, 0x63, 0x50, 0xbf,
	0xae, 0xf6, 0x7e, 0xd6, 0x7f, 0x61, 0x4b, 0xfd, 0xbc, 0xf9, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x79,
	0x52, 0xd2, 0xff, 0x2e, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// DataConnectorClient is the client API for DataConnector service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DataConnectorClient interface {
	Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (DataConnector_QueryClient, error)
}

type dataConnectorClient struct {
	cc grpc.ClientConnInterface
}

func NewDataConnectorClient(cc grpc.ClientConnInterface) DataConnectorClient {
	return &dataConnectorClient{cc}
}

func (c *dataConnectorClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc.CallOption) (DataConnector_QueryClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DataConnector_serviceDesc.Streams[0], "/cape.DataConnector/Query", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataConnectorQueryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataConnector_QueryClient interface {
	Recv() (*Record, error)
	grpc.ClientStream
}

type dataConnectorQueryClient struct {
	grpc.ClientStream
}

func (x *dataConnectorQueryClient) Recv() (*Record, error) {
	m := new(Record)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DataConnectorServer is the server API for DataConnector service.
type DataConnectorServer interface {
	Query(*QueryRequest, DataConnector_QueryServer) error
}

// UnimplementedDataConnectorServer can be embedded to have forward compatible implementations.
type UnimplementedDataConnectorServer struct {
}

func (*UnimplementedDataConnectorServer) Query(req *QueryRequest, srv DataConnector_QueryServer) error {
	return status.Errorf(codes.Unimplemented, "method Query not implemented")
}

func RegisterDataConnectorServer(s *grpc.Server, srv DataConnectorServer) {
	s.RegisterService(&_DataConnector_serviceDesc, srv)
}

func _DataConnector_Query_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QueryRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataConnectorServer).Query(m, &dataConnectorQueryServer{stream})
}

type DataConnector_QueryServer interface {
	Send(*Record) error
	grpc.ServerStream
}

type dataConnectorQueryServer struct {
	grpc.ServerStream
}

func (x *dataConnectorQueryServer) Send(m *Record) error {
	return x.ServerStream.SendMsg(m)
}

var _DataConnector_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cape.DataConnector",
	HandlerType: (*DataConnectorServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Query",
			Handler:       _DataConnector_Query_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "data_connector.proto",
}
